import Foundation
import JavaScriptCore
import SourceKittenFramework
import SQLite

/// File-based rule engine that loads TypeScript/JavaScript rules from RulePacks
///
/// Architecture:
/// RulePacks/ (TypeScript files) â†’ Compilation â†’ JavaScriptCore (Execution) â†’ SQLite (Analytics)
///
class FileBasedRuleEngine {
    private let context: JSContext
    private let database: RuleDatabase
    private var loadedRules: [FileBasedRule] = []
    private let rulePacksDirectory: URL

    init(database: RuleDatabase) {
        self.database = database
        self.context = JSContext()
        
        // Get RulePacks directory
        let currentDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
        self.rulePacksDirectory = currentDir.appendingPathComponent("RulePacks")

        // Setup JavaScript environment
        setupJavaScriptEnvironment()

        print("ðŸŸ¢ FileBasedRuleEngine initialized with file-based TypeScript rules")
    }

    // MARK: - Environment Setup

    private func setupJavaScriptEnvironment() {
        // Enable exception handling for debugging
        context.exceptionHandler = { context, exception in
            print("âŒ JavaScript Exception: \(exception?.toString() ?? "Unknown error")")
        }

        // Core utility functions
        setupUtilityFunctions()

        // AST analysis bridge functions
        setupASTBridgeFunctions()

        // Rule execution framework
        setupRuleExecutionFramework()

        print("ðŸ”§ JavaScript environment configured for file-based rules")
    }

    private func setupUtilityFunctions() {
        // String utilities for pattern matching
        context.evaluateScript("""
            // Enhanced string utilities for Swift pattern matching
            const StringUtils = {
                isValidSwiftIdentifier: function(str) {
                    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(str);
                },
                isCamelCase: function(str) {
                    return /^[a-z][a-zA-Z0-9]*$/.test(str);
                },
                isPascalCase: function(str) {
                    return /^[A-Z][a-zA-Z0-9]*$/.test(str);
                },
                countPattern: function(str, pattern) {
                    const regex = new RegExp(pattern, 'g');
                    const matches = str.match(regex);
                    return matches ? matches.length : 0;
                }
            };
        """)
    }

    private func setupASTBridgeFunctions() {
        // Bridge Swift AST data to JavaScript
        context.evaluateScript("""
            // AST bridge for accessing SourceKit analysis results from JavaScript
            const ASTBridge = {
                currentFile: null,
                currentDeclarations: [],
                currentSourceCode: '',

                loadFileData: function(fileData) {
                    this.currentFile = fileData;
                    this.currentDeclarations = fileData.declarations || [];
                    this.currentSourceCode = fileData.sourceCode || '';
                },

                getClasses: function() {
                    return this.currentDeclarations.filter(decl =>
                        decl.kind && (
                            decl.kind.includes('class') ||
                            decl.kind.includes('struct')
                        )
                    );
                },

                getFunctions: function() {
                    return this.currentDeclarations.filter(decl =>
                        decl.kind && decl.kind.includes('function')
                    );
                },

                sourceContains: function(pattern) {
                    const regex = new RegExp(pattern);
                    return regex.test(this.currentSourceCode);
                },

                countInSource: function(pattern) {
                    return StringUtils.countPattern(this.currentSourceCode, pattern);
                },

                countProperties: function(className) {
                    return this.currentDeclarations.filter(decl =>
                        decl.kind.includes('var.instance') &&
                        decl.name && decl.name.startsWith(className + '.')
                    ).length;
                }
            };
        """)
    }

    private func setupRuleExecutionFramework() {
        context.evaluateScript("""
            // Rule execution framework
            const RuleEngine = {
                violations: [],

                clearViolations: function() {
                    this.violations = [];
                },

                addViolation: function(violation) {
                    this.violations.push({
                        fileName: ASTBridge.currentFile.fileName || 'unknown',
                        ruleName: violation.ruleName || 'unknown',
                        severity: violation.severity || 'medium',
                        actualValue: violation.actualValue || 'violation detected',
                        expectedValue: violation.expectedValue || 'no violation',
                        hasViolation: true,
                        automationConfidence: violation.automationConfidence || 0.8,
                        recommendedAction: violation.recommendedAction || 'fix the violation',
                        type: 'rule_violation',
                        lineNumber: 0,
                        targetName: violation.targetName || ''
                    });
                },

                getViolations: function() {
                    return this.violations;
                },

                hasViolations: function() {
                    return this.violations.length > 0;
                }
            };
        """)
    }

    // MARK: - Rule Loading and Compilation

    /// Load and compile all TypeScript/JavaScript rules from RulePacks
    func loadRules() -> [FileBasedRule] {
        print("ðŸ“‚ Loading rules from RulePacks...")
        
        var rules: [FileBasedRule] = []
        
        // Find all rule files
        let ruleFiles = findRuleFiles()
        print("ðŸ” Found \(ruleFiles.count) rule files")
        
        for ruleFile in ruleFiles {
            if let rule = loadRuleFromFile(ruleFile) {
                rules.append(rule)
                print("âœ… Loaded rule: \(rule.name)")
            }
        }
        
        self.loadedRules = rules
        print("ðŸ“‹ Loaded \(rules.count) rules successfully")
        return rules
    }

    /// Reload rules from files (on-demand hot reload)
    func reloadRules() -> [FileBasedRule] {
        print("ðŸ”„ Reloading rules from RulePacks...")
        
        // Clear current context
        loadedRules.removeAll()
        
        // Reload rules
        return loadRules()
    }

    private func findRuleFiles() -> [URL] {
        var ruleFiles: [URL] = []
        
        guard let enumerator = FileManager.default.enumerator(
            at: rulePacksDirectory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else { return ruleFiles }
        
        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "ts" || fileURL.pathExtension == "js" {
                ruleFiles.append(fileURL)
            }
        }
        
        return ruleFiles.sorted { $0.path < $1.path }
    }

    private func loadRuleFromFile(_ fileURL: URL) -> FileBasedRule? {
        do {
            let fileName = fileURL.lastPathComponent
            let filePath = fileURL.path
            let ruleName = fileName.replacingOccurrences(of: ".\(fileURL.pathExtension)", with: "")
            let domain = getDomainFromPath(fileURL.path)
            
            var sourceCode = try String(contentsOf: fileURL, encoding: .utf8)
            
            // If TypeScript, compile to JavaScript
            if fileURL.pathExtension == "ts" {
                sourceCode = compileTypeScriptToJavaScript(sourceCode, fileURL: fileURL)
            }
            
            return FileBasedRule(
                name: ruleName,
                domain: domain,
                fileName: fileName,
                filePath: filePath,
                sourceCode: sourceCode,
                version: "1.0"
            )
            
        } catch {
            print("âŒ Failed to load rule from \(fileURL.lastPathComponent): \(error)")
            return nil
        }
    }

    private func compileTypeScriptToJavaScript(_ sourceCode: String, fileURL: URL) -> String {
        // Simple, conservative TypeScript to JavaScript compilation
        // Only remove the most essential TypeScript constructs
        
        var jsCode = sourceCode
        
        // Remove interface definitions only (keep the rest intact)
        jsCode = jsCode.replacingOccurrences(of: "interface\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\{[^}]*\\}", with: "", options: .regularExpression)
        
        // If it already has export function, return as-is
        if jsCode.contains("export function validate(") {
            // Just remove interface definitions and return
            return jsCode
        }
        
        // Otherwise, wrap it in an export function
        let functionPattern = "function\\s+validate\\s*\\([^)]*\\)\\s*\\{"
        if let regex = try? NSRegularExpression(pattern: functionPattern, options: []),
           let match = regex.firstMatch(in: jsCode, range: NSRange(jsCode.startIndex..., in: jsCode)) {
            
            // Extract the function body
            let afterFunction = jsCode.index(jsCode.startIndex, offsetBy: match.range.location + match.range.length)
            if afterFunction < jsCode.endIndex {
                let remainingCode = String(jsCode[afterFunction...])
                
                // Find matching closing brace
                var braceCount = 0
                var bodyEndIndex = 0
                for (index, char) in remainingCode.enumerated() {
                    if char == "{" { braceCount += 1 }
                    else if char == "}" {
                        braceCount -= 1
                        if braceCount == 0 {
                            bodyEndIndex = index + 1
                            break
                        }
                    }
                }
                
                if bodyEndIndex > 0 {
                    let bodyRange = afterFunction..<jsCode.index(afterFunction, offsetBy: bodyEndIndex)
                    let functionBody = String(jsCode[bodyRange])
                    
                    // Remove outer braces if present
                    if functionBody.hasPrefix("{") && functionBody.hasSuffix("}") {
                        let startIndex = functionBody.index(after: functionBody.startIndex)
                        let endIndex = functionBody.index(before: functionBody.endIndex)
                        if startIndex < endIndex {
                            let cleanBody = String(functionBody[startIndex..<endIndex])
                            jsCode = "export function validate(context) {\n\(cleanBody)\n}"
                        }
                    } else {
                        jsCode = "export function validate(context) {\n\(functionBody)\n}"
                    }
                }
            }
        }
        
        return jsCode
    }

    private func getDomainFromPath(_ path: String) -> String {
        let pathComponents = path.split(separator: "/")
        if let rulePacksIndex = pathComponents.firstIndex(of: "RulePacks"),
           rulePacksIndex + 1 < pathComponents.count {
            return String(pathComponents[rulePacksIndex + 1])
        }
        return "general"
    }

    // MARK: - Rule Execution

    /// Execute all loaded rules against file data
    func executeAllRules(fileData: FileAnalysisData) -> [ArchitecturalFinding] {
        var allFindings: [ArchitecturalFinding] = []

        print("ðŸ”§ Executing \(loadedRules.count) rules against \(fileData.fileName)")

        for rule in loadedRules {
            let startTime = CFAbsoluteTimeGetCurrent()
            let findings = executeRule(rule: rule, fileData: fileData)
            let duration = CFAbsoluteTimeGetCurrent() - startTime
            
            print("â±ï¸ Rule '\(rule.name)' executed in \(String(format: "%.3f", duration))s")
            
            allFindings.append(contentsOf: findings)
        }

        return allFindings
    }

    private func executeRule(rule: FileBasedRule, fileData: FileAnalysisData) -> [ArchitecturalFinding] {
        // Clear previous violations
        self.context.evaluateScript("RuleEngine.clearViolations();")

        // Load file data into JavaScript environment
        loadFileDataIntoJS(fileData, rule: rule)

        // Create execution context
        let executionScript = """
            (function() {
                try {
                    // Load rule module
                    const module = {};
                    const exports = {};
                    
                    // Execute the rule code with a try-catch
                    \(rule.sourceCode)
                    
                    // Execute the rule if it has the right format
                    if (exports && typeof exports.validate === 'function') {
                        exports.validate({
                            astBridge: ASTBridge,
                            ruleEngine: RuleEngine,
                            currentFile: {
                                lines: \(fileData.lines),
                                fileName: "\(fileData.fileName)"
                            },
                            currentSourceCode: ASTBridge.currentSourceCode
                        });
                    }

                    return { success: true, message: "Rule executed successfully" };
                } catch (error) {
                    RuleEngine.addViolation({
                        ruleName: "\(rule.name)",
                        severity: "low",
                        actualValue: "Rule execution error: " + error.toString(),
                        expectedValue: "Successful rule execution",
                        automationConfidence: 0.0,
                        recommendedAction: "Fix rule code",
                        targetName: "rule_execution_error"
                    });

                    return { success: false, error: error.toString() };
                }
            })();
        """

        // Execute the rule
        self.context.evaluateScript(executionScript)

        // Extract violations from JavaScript
        return extractViolationsFromJS(rule: rule, fileData: fileData)
    }

    private func loadFileDataIntoJS(_ fileData: FileAnalysisData, rule: FileBasedRule) {
        // Convert Swift data to JavaScript-compatible format
        let fileDataDict: [String: Any] = [
            "fileName": fileData.fileName,
            "filePath": fileData.filePath,
            "sourceCode": fileData.sourceCode,
            "lines": fileData.lines,
            "declarations": fileData.declarations.map { declaration in
                [
                    "name": declaration.name,
                    "kind": declaration.kind,
                    "offset": declaration.offset,
                    "length": declaration.length,
                    "bodyOffset": declaration.bodyOffset as Any,
                    "bodyLength": declaration.bodyLength as Any
                ]
            }
        ]

        // Convert to JSON and load into JavaScript
        guard let jsonData = try? JSONSerialization.data(withJSONObject: fileDataDict),
              let jsonString = String(data: jsonData, encoding: .utf8) else {
            print("âŒ Failed to serialize file data for rule \(rule.name)")
            return
        }

        self.context.evaluateScript("ASTBridge.loadFileData(\(jsonString));")
    }

    private func extractViolationsFromJS(rule: FileBasedRule, fileData: FileAnalysisData) -> [ArchitecturalFinding] {
        guard let violationsResult = self.context.evaluateScript("RuleEngine.getViolations();"),
              let violationsArray = violationsResult.toArray() as? [[String: Any]] else {
            return []
        }

        return violationsArray.compactMap { violationDict in
            guard let ruleName = violationDict["ruleName"] as? String,
                  let actualValue = violationDict["actualValue"] as? String,
                  let recommendedAction = violationDict["recommendedAction"] as? String else {
                return nil
            }

            let severityString = violationDict["severity"] as? String ?? "medium"
            let automationConfidence = violationDict["automationConfidence"] as? Double ?? 0.8

            return ArchitecturalFinding(
                fileName: fileData.fileName,
                filePath: fileData.filePath,
                ruleName: ruleName,
                severity: ViolationSeverity(rawValue: severityString) ?? .medium,
                lines: fileData.lines,
                actualValue: actualValue,
                expectedValue: violationDict["expectedValue"] as? String ?? "No violation expected",
                hasViolation: violationDict["hasViolation"] as? Bool ?? true,
                automationConfidence: automationConfidence,
                recommendedAction: recommendedAction,
                type: violationDict["type"] as? String ?? "rule_violation"
            )
        }
    }
}

// MARK: - Supporting Data Structures

struct FileAnalysisData {
    let fileName: String
    let filePath: String
    let sourceCode: String
    let lines: Int
    let declarations: [DeclarationInfo]
}

struct FileBasedRule {
    let name: String
    let domain: String
    let fileName: String
    let filePath: String
    let sourceCode: String
    let version: String
}
