// smith-validation/Reporting/ValidationReporter.swift
// Structured reporting using Swift Testing patterns

import Foundation
import SmithValidationCore

/// Structured validation reporter with better organization
public struct ValidationReporter {

    public struct ReportSummary {
        public let totalFiles: Int
        public let parsedFiles: Int
        public let totalViolations: Int
        public let criticalViolations: Int
        public let highViolations: Int
        public let mediumViolations: Int
        public let lowViolations: Int

        public var hasViolations: Bool { totalViolations > 0 }
        public var healthScore: Int {
            guard totalFiles > 0 else { return 100 }
            let deductionPerViolation = 2
            let maxDeduction = min(totalViolations * deductionPerViolation, 100)
            return max(0, 100 - maxDeduction)
        }
    }

    public struct RuleSection {
        public let ruleNumber: String
        public let ruleName: String
        public let violations: [ArchitecturalViolation]

        public var count: Int { violations.count }
        public var criticalCount: Int { violations.filter { $0.severity == .critical }.count }
        public var highCount: Int { violations.filter { $0.severity == .high }.count }
        public var mediumCount: Int { violations.filter { $0.severity == .medium }.count }
        public var lowCount: Int { violations.filter { $0.severity == .low }.count }
    }

    public static func generateReport(
        for violationsCollections: [(rule: String, violations: ViolationCollection)],
        totalFiles: Int = 0,
        parsedFiles: Int = 0
    ) -> String {
        let summary = calculateSummary(
            collections: violationsCollections,
            totalFiles: totalFiles,
            parsedFiles: parsedFiles
        )

        var report = [String]()

        // Header
        report.append("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        report.append("â•‘                    ðŸ§  SMITH VALIDATION - ARCHITECTURAL REPORT                 â•‘")
        report.append("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        report.append("")

        // Summary
        report.append("ðŸ“Š VALIDATION SUMMARY")
        report.append(String(format: "   Files Scanned: %d", totalFiles))
        report.append(String(format: "   Files Parsed: %d", parsedFiles))
        report.append(String(format: "   Health Score: %d%%", summary.healthScore))
        report.append("")

        // Violations breakdown
        if summary.hasViolations {
            report.append("ðŸš¨ VIOLATIONS OVERVIEW")
            report.append(String(format: "   Total: %d (ðŸ”´ Critical: %d, ðŸŸ  High: %d, ðŸŸ¡ Medium: %d, ðŸŸ¢ Low: %d)",
                summary.totalViolations, summary.criticalViolations,
                summary.highViolations, summary.mediumViolations, summary.lowViolations))
            report.append("")
        } else {
            report.append("âœ… NO VIOLATIONS DETECTED - Excellent architectural health!")
            report.append("")
        }

        // Rule details
        for (index, collection) in violationsCollections.enumerated() {
            let ruleSection = RuleSection(
                ruleNumber: String(collection.rule.split(separator: ".").last ?? "Unknown"),
                ruleName: getRuleDisplayName(collection.rule),
                violations: collection.violations.violations
            )

            report.append(ruleSectionReport(ruleSection, index: index + 1))
        }

        // Footer
        report.append("â”€" * 80)
        report.append("ðŸ¤– Generated by smith-validation - TCA Architectural Pattern Detection")
        report.append("ðŸ“– Framework: The Composable Architecture (TCA)")
        report.append("ðŸŽ¯ Rules: Monolithic Features, Dependencies, Duplication, Organization, Coupling")
        report.append("")

        return report.joined(separator: "\n")
    }

    public static func generateSwiftTestingStyleReport(
        for violationsCollections: [(rule: String, violations: ViolationCollection)],
        totalFiles: Int = 0,
        parsedFiles: Int = 0,
        maxExamplesPerRule: Int = 5
    ) -> String {
        let summary = calculateSummary(
            collections: violationsCollections,
            totalFiles: totalFiles,
            parsedFiles: parsedFiles
        )

        var report: [String] = []
        let formatter = ISO8601DateFormatter()
        let startedAt = formatter.string(from: Date())
        report.append("Test Suite 'SmithValidation.TCA' started at \(startedAt)")
        report.append(String(format: "Scanning %d Swift files (%d parsed successfully)", totalFiles, parsedFiles))
        report.append("")

        for (rule, collection) in violationsCollections {
            let ruleName = "TCA Rule \(rule): \(getRuleDisplayName(rule))"
            report.append("Test Case '\(ruleName)' started.")

            if collection.count == 0 {
                report.append("Test Case '\(ruleName)' passed (0.00 seconds).")
                report.append("")
                continue
            }

            let limitedViolations = Array(collection.violations.prefix(max(1, maxExamplesPerRule)))
            for violation in limitedViolations {
                let location = violation.line > 0 ? "\(violation.file):\(violation.line)" : violation.file
                report.append("    âœ— [\(violation.severity.emoji)] \(location) â€” \(violation.message)")
                if let recommendation = violation.recommendation {
                    report.append("      ðŸ’¡ \(recommendation)")
                }
            }

            if collection.count > limitedViolations.count {
                report.append("    â€¦ \(collection.count - limitedViolations.count) additional violation(s) not shown")
            }

            report.append("Test Case '\(ruleName)' failed (\(collection.count) violation(s)).")
            report.append("")
        }

        let endedAt = formatter.string(from: Date())
        let failedSuites = violationsCollections.filter { $0.violations.count > 0 }.count
        let suiteStatus = failedSuites == 0 ? "passed" : "failed"
        report.append("Test Suite 'SmithValidation.TCA' \(suiteStatus) at \(endedAt).")
        report.append(
            String(
                format: "     Executed %d test(s), with %d failure(s), %d violation(s) total (ðŸ”´ Critical: %d, ðŸ”´ High: %d, ðŸŸ  Medium: %d, ðŸŸ¡ Low: %d)",
                violationsCollections.count,
                failedSuites,
                summary.totalViolations,
                summary.criticalViolations,
                summary.highViolations,
                summary.mediumViolations,
                summary.lowViolations
            )
        )
        report.append("")
        return report.joined(separator: "\n")
    }

    private static func ruleSectionReport(_ section: RuleSection, index: Int) -> String {
        var report = [String]()

        let header = String(format: "%d. TCA Rule %@: %@", index, section.ruleNumber, section.ruleName)
        let separator = String(repeating: "â”€", count: header.count)

        report.append(header)
        report.append(separator)
        report.append(String(format: "Violations: %d (ðŸ”´ Critical: %d, ðŸŸ  High: %d, ðŸŸ¡ Medium: %d)",
            section.count, section.criticalCount, section.highCount, section.mediumCount))

        if section.count == 0 {
            report.append("   âœ… No violations detected")
        } else {
            // Show unique violations (avoid duplicates)
            let uniqueViolations = deduplicateViolations(section.violations)
            report.append("")
            report.append("ðŸ” Key Issues Found:")

            for (violationIndex, violation) in uniqueViolations.enumerated() {
                report.append(String(format: "   %d. %@ %@",
                    violationIndex + 1,
                    violation.severity.emoji,
                    violation.rule))
                report.append(String(format: "      %@", violation.message))

                if let recommendation = violation.recommendation {
                    report.append(String(format: "      ðŸ’¡ %@", recommendation))
                }

                // Add file context if available
                if !violation.file.isEmpty && violation.file != "Unknown" {
                    report.append(String(format: "      ðŸ“ %@", violation.file))
                }

                report.append("")
            }

            if section.count > uniqueViolations.count {
                report.append(String(format: "   ... and %d similar violation(s) not shown",
                    section.count - uniqueViolations.count))
                report.append("")
            }
        }

        return report.joined(separator: "\n")
    }

    private static func calculateSummary(
        collections: [(rule: String, violations: ViolationCollection)],
        totalFiles: Int,
        parsedFiles: Int
    ) -> ReportSummary {
        let allViolations = collections.flatMap { $0.violations.violations }

        return ReportSummary(
            totalFiles: totalFiles,
            parsedFiles: parsedFiles,
            totalViolations: allViolations.count,
            criticalViolations: allViolations.filter { $0.severity == .critical }.count,
            highViolations: allViolations.filter { $0.severity == .high }.count,
            mediumViolations: allViolations.filter { $0.severity == .medium }.count,
            lowViolations: allViolations.filter { $0.severity == .low }.count
        )
    }

    private static func getRuleDisplayName(_ ruleKey: String) -> String {
        switch ruleKey {
        case "1.1": return "Monolithic Features"
        case "1.2": return "Proper Dependency Injection"
        case "1.3": return "Code Duplication"
        case "1.4": return "Unclear Organization"
        case "1.5": return "Tightly Coupled State"
        default: return "Unknown Rule"
        }
    }

    private static func deduplicateViolations(_ violations: [ArchitecturalViolation]) -> [ArchitecturalViolation] {
        var uniqueViolations: [ArchitecturalViolation] = []
        var seenMessages = Set<String>()

        for violation in violations {
            let key = "\(violation.rule):\(violation.message)"
            if !seenMessages.contains(key) {
                seenMessages.insert(key)
                uniqueViolations.append(violation)
            }
        }

        // Limit to first 10 unique violations for readability
        return Array(uniqueViolations.prefix(10))
    }
}

extension String {
    static func * (left: String, right: Int) -> String {
        return String(repeating: left, count: right)
    }
}
